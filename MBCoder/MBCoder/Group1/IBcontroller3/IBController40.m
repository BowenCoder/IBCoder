//
//  IBController40.m
//  IBCoder1
//
//  Created by Bowen on 2018/7/27.
//  Copyright © 2018年 BowenCoder. All rights reserved.
//

#import "IBController40.h"
#import "ReactiveObjC.h"
@interface IBController40 ()

@end

@implementation IBController40

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    
}

@end

/*
 一、动态库和静态库的区别
 
 库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。
 
 1. 静态函数库
 这类库的名字一般是libxxx.a；利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，
 他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也
 会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。
 
 2. 动态函数库
 相对于静态函数库，动态函数库在编译的时候 并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，
 因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行
 环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。
 
 静态库和动态库都是由*.o目标文件生成的，这是他们的相同之处。

 
 
 使用静态库的好处
 1，模块化，分工合作
 2，避免少量改动经常导致大量的重复编译连接
 3，也可以重用，注意不是共享使用
 
 动态库使用有如下好处：
 1、可以将最终可执行文件体积缩小
 2、多个应用程序共享内存中得同一份库文件，节省资源
 3、可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。
 从1可以得出，将整个应用程序分模块，团队合作，进行分工，影响比较小等其他好处，
 从2可以看出，其实动态库应该叫共享库，那么从这个意义上来说，苹果禁止iOS开发中使用动态库就可以理解了：
 因为在现在的iPhone，iPodTouch，iPad上面程序都是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，
 ----共享给谁？（你使用的时候只有你一个应用程序存在，其他的应该被挂起了，即便是可以同时多个进程运行，别人能使用你的共享库里的东西吗？
 你这个是给你自己的程序定制的。）
 ----目前苹果的AppStore不支持模块更新，无法更新某个单独文件(除非自己写一个更新机制：有自己的服务端放置最新动态库文件)
 
 至于苹果为什么禁止ios开发使用动态库我就猜到上面俩原因。
 iPhone官方只支持静态库联编。
 由于ios开发，官方只支持静态库联编，所以在实际的开发中，系那个要实现模块化分工合作，只能使用静态库了。
 
 
 二、内联函数
 实现思想：
 内联函数的基本思想在于将每个函数调用以它的代码体来替换，很可能会增加整个目标代码的体积过分地使用内联所产生的程序
 会因为有太大的体积而导致可用空间不够。如果内联函数体非常短，编译器为这个函数体生成的代码就会真的比为函数调用生成
 的代码要小许多。如果是这种情况，内联这个函数将会确实带来更小的目标代码和更高的缓存命中率！
 
 内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处
 的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。
 
 三、静态函数
 C语言中使用静态函数的好处：
 静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
 
 
 C程序一直由下列部分组成：
 1）正文段——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；
 2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。
 3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。
 4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。
 5）堆——动态存储分。
 
 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
 1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
 3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
 
 好处：
 定义全局静态变量的好处：
 <1>不会被其他文件所访问，修改
 <2>其他文件中可以使用相同名字的变量，不会发生冲突。
 
 局部静态变量
 在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
 1）内存中的位置：静态存储区
 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
 3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
 
 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，
 并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。

 
 3. 静态函数
 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。
 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
 定义静态函数的好处：
 <1> 其他文件中可以定义相同名字的函数，不会发生冲突
 <2> 静态函数不能被其他文件所用。 存储说明符auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。
     auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出
     该程序块时撤销。关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期
    （static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性
     仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。
     由于static变量的以上特性，可实现一些特定功能。比如， 统计次数功能
 
 */
